{
  "id": "eval-ssr-dotnet-angular",
  "title": "Evaluación Técnica: Sr. .NET C# Backend con Angular 17",
  "categories": [
    {
      "id": "cat-csharp-dotnet-core",
      "title": "C# & .NET Core Avanzado",
      "questions": [
        {
          "id": "q-async-performance",
          "question": "Describe tu experiencia optimizando operaciones asíncronas (async/await) en escenarios de alta concurrencia en C#.",
          "type": "scale",
          "scaleMax": 5,
          "example": "En un endpoint que recibía miles de requests por minuto, identificamos alta alocación de memoria por el uso de 'Task<T>'. Refactorizamos los métodos críticos para que devolvieran 'ValueTask<T>', ya que muchos resultados se obtenían de caché sincrónicamente. Además, usamos 'ConfigureAwait(false)' en servicios de librería para evitar deadlocks al no necesitar volver al contexto de sincronización original."
        },
        {
          "id": "q-memory-gc",
          "question": "Explica cómo has diagnosticado y resuelto problemas de gestión de memoria o presión sobre el Garbage Collector (GC) en .NET.",
          "type": "scale",
          "scaleMax": 5,
          "example": "Teníamos un servicio de procesamiento de imágenes que sufría de alta fragmentación en el 'Large Object Heap' (LOH) y frecuentes GCs de Gen 2. Usando 'dotnet-counters' y 'dotnet-trace', vimos que el problema era la alocación constante de 'byte[]' grandes. Resolvimos esto usando 'ArrayPool<byte>.Shared' para reutilizar buffers de memoria en lugar de crear nuevos, reduciendo drásticamente las pausas del GC."
        }
      ]
    },
    {
      "id": "cat-aspnet-api",
      "title": "ASP.NET Core & Diseño de API",
      "questions": [
        {
          "id": "q-di-lifetimes",
          "question": "Explica los trade-offs entre los 'lifetimes' de Inyección de Dependencias (Singleton, Scoped, Transient) y un error común que hayas resuelto relacionado con esto.",
          "type": "scale",
          "scaleMax": 5,
          "example": "Teníamos un 'memory leak' difícil de trazar. Descubrimos que un servicio registrado como 'Singleton' estaba inyectando un 'DbContext' (que es 'Scoped'). El Singleton mantenía la referencia al DbContext de la primera request indefinidamente. Lo solucionamos inyectando 'IServiceScopeFactory' en el Singleton y creando manualmente un 'scope' nuevo para cada operación que necesitaba el DbContext."
        },
        {
          "id": "q-middleware-pipeline",
          "question": "Describe un 'middleware' personalizado complejo que hayas implementado en ASP.NET Core y el problema que resolvía.",
          "type": "scale",
          "scaleMax": 5,
          "example": "Implementamos un middleware de 'Circuit Breaker' personalizado. Interceptaba las 'HttpClientException' dirigidas a un microservicio externo crítico. Tras 3 fallos consecutivos, 'abría el circuito' y durante 60 segundos respondía directamente con un 'fallback' (ej. datos de caché), evitando que nuestra API fallara en cascada y dando tiempo al otro servicio a recuperarse."
        }
      ]
    },
    {
      "id": "cat-ef-core",
      "title": "Data Access & Entity Framework Core",
      "questions": [
        {
          "id": "q-ef-performance",
          "question": "Menciona estrategias avanzadas de optimización de rendimiento que uses con Entity Framework Core al consultar grandes volúmenes de datos.",
          "type": "scale",
          "scaleMax": 5,
          "example": "Para reportes pesados, siempre usamos 'AsNoTracking()' para evitar la sobrecarga del 'change tracking'. Cuando necesitábamos datos complejos, en lugar de múltiples 'Includes' que generaban 'cartesian explosion', usamos 'Query Splitting' ('AsSplitQuery()') para generar consultas SQL separadas y más eficientes. Para actualizaciones masivas, usamos 'ExecuteUpdateAsync' (de EF Core 7+) para evitar cargar miles de entidades en memoria."
        },
        {
          "id": "q-concurrency",
          "question": "¿Cómo has gestionado conflictos de concurrencia optimista (Optimistic Concurrency) en EF Core?",
          "type": "scale",
          "scaleMax": 5,
          "example": "Usamos un 'timestamp' o 'row version' (mapeado con 'IsRowVersion()'). En el frontend (Angular), enviábamos este 'row version' junto con el DTO al actualizar. En el backend, EF Core automáticamente compara este valor. Si no coincide, lanza 'DbUpdateConcurrencyException'. Capturamos esa excepción y devolvemos un 409 Conflict, para que el frontend pueda notificar al usuario que los datos fueron modificados por otra persona."
        }
      ]
    },
    {
      "id": "cat-angular-17",
      "title": "Angular 17 (Conceptos Modernos)",
      "questions": [
        {
          "id": "q-angular-signals",
          "question": "Explica la diferencia clave entre 'computed' y 'effect' en Angular Signals y cómo los usas en un escenario real.",
          "type": "scale",
          "scaleMax": 5,
          "example": "Usamos 'Signals' para gestionar el estado de un carrito de compras. Teníamos una señal 'cartItems'. Usamos 'computed' para derivar estado de forma perezosa: 'totalPrice = computed(() => this.cartItems().reduce(...))'. Este valor solo se recalcula si 'cartItems' cambia y algo lo está leyendo. Usamos 'effect' para un 'side effect': 'effect(() => localStorage.setItem('cart', JSON.stringify(this.cartItems())))', que se ejecuta automáticamente cuando el carrito cambia para persistirlo."
        },
        {
          "id": "q-angular-defer",
          "question": "¿Cómo utilizas el nuevo bloque '@defer' (Deferrable Views) de Angular 17 para optimizar la carga inicial de una página (LCP)?",
          "type": "scale",
          "scaleMax": 5,
          "example": "En el 'dashboard' principal, teníamos un componente de 'Gráficos Avanzados' que era muy pesado e importaba 'Chart.js'. Este componente no era visible 'above the fold'. Lo envolvimos en un '@defer (on viewport)' con un '@placeholder' simple. Esto sacó el componente y 'Chart.js' del 'bundle' inicial, mejorando el 'Largest Contentful Paint' (LCP) en casi un segundo, ya que el 'bundle' principal se redujo significativamente."
        }
      ]
    },
    {
      "id": "cat-fullstack-arch",
      "title": "Arquitectura Full-Stack (.NET + Angular)",
      "questions": [
        {
          "id": "q-auth-jwt",
          "question": "Describe tu implementación de autenticación y autorización entre una API .NET y una SPA Angular (ej. JWT, OIDC).",
          "type": "scale",
          "scaleMax": 5,
          "example": "Usamos OIDC con Duende IdentityServer en el backend. La API .NET valida los 'Access Tokens' (JWT) en cada request. Angular usa un 'HttpInterceptor' que adjunta el 'Access Token' (obtenido de 'localStorage' o 'sessionStorage') al 'Authorization header'. El interceptor también maneja las respuestas 401 (Unauthorized): si detecta un 401, intenta usar un 'Refresh Token' para obtener un nuevo 'Access Token' de forma silenciosa. Si eso falla, redirige al usuario al 'login'."
        },
        {
          "id": "q-state-caching",
          "question": "Explica cómo has combinado la gestión de estado en Angular (ej. Ngrx, Servicios+Signals) con estrategias de caché en el backend .NET.",
          "type": "scale",
          "scaleMax": 5,
          "example": "Usamos Ngrx en Angular para el 'store'. Para datos de 'catálogo' (que cambian poco), el 'effect' de Ngrx solo llama a la API si el 'store' está vacío. En el backend (.NET), implementamos 'Output Caching' (de ASP.NET Core 7+) en esos 'endpoints' de catálogo por 10 minutos. Cuando un administrador actualizaba un producto (POST/PUT), el backend usaba 'ITaggedCacheOutputFeature' para invalidar (purgar) el caché de ese catálogo específico, forzando la siguiente petición (de cualquier usuario) a obtener datos frescos."
        }
      ]
    }
  ]
}